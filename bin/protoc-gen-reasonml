#!/usr/bin/env node
/* Why is protobufjs giving me JS Number values to represent protobufs
 * enum values when grpc gives me JS String values?
 *
 * https://github.com/dcodeIO/protobuf.js/issues/97
 */
const pbjs = require('protobufjs')
const protobufs = require('../src/protobufs')
const path = require('path')
const fs = require('fs')
const util = require('util')
const toposort = require('toposort')

const quote = s => {
  if ('string' !== typeof s)
    throw new Error("expecting string")
  return JSON.stringify(s)
}
const moduleDirName = moduleName => moduleName.split('.').slice(0, -1).join('.');
const FILE_MAGIC = '/* AUTO-GENERATED BY bs-grpc --- EDIT AT YOUR OWN PERIL */\n';
const preBoilerPlate = `
  exception BsGrpcDecoderError(string);
  exception ImpossibleError(string);
  let (<<) = (f, g, x) => f(g(x));
  /** an opaque type for error objects from grpc-node when the client invokes
   an RPC */
  type grpcClientRpcInvokeError;
  /* simply wraps grpcClientRpcInvokeError when an exception is needed */
  exception GrpcClientRpcInvokeError(grpcClientRpcInvokeError);

  /* "channel credentials" seem to be needed for creating a client */
  type channelCredentials;
  type callCredentials;
  type serverCredentials;

  /* protobufjs uses ByteBuffer abstraction over Node Buffer */
  type byteBuffer;
  [@bs.send] external bufferOfByteBuffer : byteBuffer => Node.buffer = "finish";

  /* flatMap an array of Futures */
  let futureFlatMapArray =
      (f: 'a => Future.t('b), maxConcurrent, xs: array('a)) =>
    Future.(
      make(resolve => {
        let result: array(option('b)) =
          xs |. Array.length |. Belt.Array.make(None);
        let xlen = Array.length(xs);
        let numJobs = ref(0);
        let cursor = ref(0);
        let rec pump = () => {
          if (cursor^ == xlen) {
            if (numJobs^ == 0) {
              result |> Array.map(Belt.Option.getExn) |. resolve;
            };
          } else {
            let i = cursor^;
            cursor := cursor^ + 1;
            numJobs := numJobs^ + 1;
            xs[i]
            |. f
            |. get(x => {
                 result[i] = Some(x);
                 numJobs := numJobs^ - 1;
                 pump();
               });
          };
          ();
        };
        for (_ in 1 to min(maxConcurrent, xlen)) {
          pump();
        };
        ();
      })
    );

  /** return Some(x) for the first x of an array for which predictate f
   returns true, starting from element at index n, or None if no such element is
   found */
  let rec arrayFirst = (f, n, a) =>
    n < Array.length(a) ? f(a[n]) ? Some(a[n]) : arrayFirst(f, n + 1, a) : None;

  /* utility eunction; TODO is there a stdlib answer? */
  let optCall = (x, ~f) =>
    switch (x) {
    | None => ()
    | Some(x) => f(x)
    };

  /** Convenience function for simplifying server replies */
  let reply = (callback, x) =>
    callback(.
      Js.Nullable.null,
      x,
      Js.Nullable.undefined,
      Js.Nullable.undefined,
    );

  module Validation = {
    exception MissingFieldError;
    exception StringTooLongError;
    exception StringTooShortError;
    exception ArrayTooShortError;
    exception FractionalNumberError;
    exception WrongStringError;
    exception UnimplementedError;
    exception WrongNumberError;
    exception NumberOutOfRangeError;
    exception NumberNotPositiveError;
    exception RegexMatchError;
    exception TransFieldError(string);
    exception EmptyOneof(string);

    /* invokes user-supplied function to perform multi-field
     * validation, if such a function is supplied
     * TODO move to Validation module */
    let transFieldError = errMsg => Belt.Result.Error(
      TransFieldError(errMsg)
    );

    type field('a) =
      | Field(string, Future.t(Belt.Result.t(option('a), exn)));
    let fieldMap = (f, Field(fieldName, x)) => Field(fieldName, f(x));
    let fieldGet = (Field(_, x)) => x;
    let futureMap = (a, b) => Future.map(b, a);
    let futureFlatMap = (a, b) => Future.map(b, a);
    let resultMap = (a, b) => Belt.Result.map(b, a);
    let resultFlatMap = (a, b) => Belt.Result.flatMap(b, a);
    let optionMap = (a, b) => Belt.Option.map(b, a);
    let optionFlatMap = (a, b) => Belt.Option.flatMap(b, a);
    let resultOptionFlatMap = f => fun
    | Belt.Result.Ok(Some(x)) => f(x)
    | x => x
    ;
    let okSome = x => Belt.Result.Ok(Some(x));
    let error = e => Belt.Result.Error(e);

    let value = (fieldName, x) =>
      Field(fieldName, Future.value(Belt.Result.Ok(x)));
    let fieldValidatorOfMessageValidator = (f, Field(name, future)) =>
      future
      |. Future.flatMapOk(x =>
           switch (x) {
           | None => None |. Belt.Result.Ok |. Future.value
           | Some(thing) =>
             f(thing)
             |. Future.mapError(str => str |. TransFieldError)
             |. Future.mapOk(x => Some(x))
           }
         )
      |. (fresult => Field(name, fresult));


    let numberRange = (lo, hi) =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x => 
          lo <= x && x <= hi ? okSome(x) : error(NumberOutOfRangeError)
      );
    let maxNumber = numberRange(Js.Int.min);
    let minNumber = n => numberRange(n, Js.Int.max);
    /* TODO can isEqualNumber and isEqualString be merged? */
    let isEqualNumber = n =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          x == n ?  okSome(x) : error(WrongNumberError)
      );
    let isEqualString = s =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
                                     x == s ? okSome(x) : error(WrongStringError)
      );
    let isInt =
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          Js.Math.trunc(x) == x ?
            okSome(x) : error(FractionalNumberError)
      );
    /* TODO can notEqualNumber and notEqualString be merged? */
    let notEqualNumber = n =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          x != n ?
            okSome(x) : error(WrongNumberError)
      );
    let notEqualString = s =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          s == x ?
            okSome(x) : error(WrongStringError)
      );
    /* TODO is this in the stdlib? */
    [@bs.new] external newRegExp : string => Js.Re.t = "RegExp";
    let matchRegex = re => {
      let re = newRegExp(re);
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
        x |. Js.Re.test(re) ? okSome(x) : error(RegexMatchError)
      );
    };
    let required = x =>
      x
      |> fieldMap @@
      futureMap(
        fun
        | Belt.Result.Ok(None) => error(MissingFieldError)
        | x => x,
      );
    let maxStrLen = len =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          x |. String.length <= len ?
            okSome(x) : error(StringTooLongError)
      );
    let minStrLen = len =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          x |. String.length >= len ?
            okSome(x) : error(StringTooShortError)
      );
    let nonEmptyString = minStrLen(1);
    let trimString =
      fieldMap @@ futureMap @@ resultMap @@ optionMap @@ Js.String.trim;

    /* TODO implement in terms of previous validators */
    let positive = minNumber(1);
    /* Is US Employer Identification Numebr? */
    /* let isUSEIN */
    let repeated:
    (field('a) => field('a), field(array('a))) => field(array('a)) =
    (f, Field(fieldName, future)) => {
      let foo = x =>
        switch (x) {
        | None => None |. Belt.Result.Ok |. Future.value
        | Some(thing) =>
          let bar =
            thing
            |> futureFlatMapArray(
                 x =>
                   Field(fieldName, Future.value(Belt.Result.Ok(Some(x))))
                   |> f
                   |> fieldGet
                   |. Future.mapOk(Belt.Option.getExn),
                 0x7fffffff,
               );

          bar
          |. Future.map(
               (x: array(Belt.Result.t('a, exn))) => {
               let firstError = arrayFirst(Belt.Result.isError, 0, x);
               switch (firstError) {
               | Some(Belt.Result.Error(x)) => Belt.Result.Error(x)
               | None => Belt.Result.Ok(Array.map(Belt.Result.getExn, x))
               | Some(Belt.Result.Ok(_)) =>
                 raise(ImpossibleError("found unfound element"))
               };
             })
          |. Future.mapOk(x => Some(x));
        };
      let future = Future.flatMapOk(future, foo);
      Field(fieldName, future);
    };

    let minItemCount = (len, x: field(array('a))) =>
      x
      |> fieldMap @@
      futureMap(
        fun
        | Belt.Result.Ok(Some(x)) =>
          x |. Array.length < len ?
            Belt.Result.Error(ArrayTooShortError) : Belt.Result.Ok(Some(x))
        | x => x,
      );
    let maxItemCount = (len, x: field(array('a))) =>
      x
      |> fieldMap @@
      futureMap(
        fun
        | Belt.Result.Ok(Some(x)) =>
          x |. Array.length > len ?
            Belt.Result.Error(ArrayTooShortError) : Belt.Result.Ok(Some(x))
        | x => x,
      );

    let err2msg =
      fun
      | MissingFieldError => "required field missing"
      | StringTooLongError => "string value too long"
      | StringTooShortError => "string value too short"
      | NumberNotPositiveError => "number value non-positive"
      | ArrayTooShortError => "not enough items"
      | FractionalNumberError => "number is fractional"
      | WrongStringError => "string mismatch"
      | UnimplementedError => "unimplemented validation"
      | WrongNumberError => "wrong number"
      | NumberOutOfRangeError => "number ouf ot range"
      | RegexMatchError => "string pattern mismatch"
      | TransFieldError(s) => "involving multiple fields: " ++ s
      | _ => "unknown error";

    let fold = (Field(fieldName, Future.Future(get)), happy, sad) =>
      get(x =>
        switch (x) {
        | Belt.Result.Ok(x) => happy(x)
        | Belt.Result.Error(err) => err |> err2msg |> sad(fieldName)
        }
      );
  };

  /** a type that cannot be instantiated */
  type uninstantiable;
  /** a type to only hold values like Js.Nullable.null and
   * Js.Nullable.undefined */
  type justNull = Js.Nullable.t(uninstantiable);
  type grpcLoadResult;

  [@bs.module "bs-grpc"] external grpcLoadProto : string => grpcLoadResult = "load";

  /* Represents a grpc.Server object */
  type server;
`
const boilerPlate = `
  /* A node.js bufffer TODO see if there is a more standard type somewhere
   * for this. We treat it as opaque, though, so it's probably okay.
   */
  type buffer;

  /* This type is part of the type of grpc.ServerCredentials.createSsl() */
  module ServerKeyAndCert {
    [@bs.deriving abstract]
    type t = {
      [@bs.as "private_key"] privateKey: buffer,
      [@bs.as "cert_chain"] certChain: buffer,
    };
  };
`

// TODO implement pascal case maker
const makeConstructorName = s => s;

let makeServerModule = (serviceModules) => {
  const servicesArgumentsList = serviceModules.map(serviceModule =>
    `~${lower1(lastDottedPart(serviceModule.moduleName))}=?,\n`
  ).join('')

  const bindServicesCode = serviceModules.map(serviceModule =>
    `${lower1(lastDottedPart(serviceModule.moduleName))}
    |. optCall(
      ~f=${serviceModule.moduleName}.addService(server)
    );
    `
  ).join('')

  return `
  module Server = {
    module Credentials = {
      /* These are the public static constructor functions for
       * grpc.ServerCredentials
       */
      module Ssl = {
        [@bs.module "@grpc/grpc-js"]
        [@bs.scope "ServerCredentials"]
        external make : (buffer, array(ServerKeyAndCert.t), bool) => serverCredentials =
          "createSsl";
        let make = (~rootCert: buffer, ~privateKey: buffer, ~certChain: buffer) =>
          make(
            rootCert,
            [|ServerKeyAndCert.t(~privateKey, ~certChain)|],
            true,
          );
      };
      module Insecure = {
        [@bs.module "@grpc/grpc-js"]
        [@bs.scope "ServerCredentials"]
        external make : unit => serverCredentials = "createInsecure";
      };
    };

    [@bs.module "@grpc/grpc-js"][@bs.new]
    external newServer : unit => server = "Server";

    [@bs.send]
    external serverBind: (server, string, serverCredentials, (string, int) => unit) => unit = "bindAsync";

    [@bs.send]
    external start : server => unit = "start";

    /** Convenience function to instantiate and configure a GRPC server */
    let make = (
      ~credentials,
      ${servicesArgumentsList}
      host,
    ) => {
      let server = newServer();
      serverBind(
        server,
        host,
        credentials,
        (error, port) => {
          ${bindServicesCode}
          start(server);
          ();
        },
      );
      server;
    };
  };
  `
}

const boilerPlate2 = `
  module Client = {
    module Metadata = {
      type t;
      [@bs.module "@grpc/grpc-js"] [@bs.new] external make : unit => t = "Metadata";
      [@bs.send] external set : (t, string, string) => unit = "";
      let set = (t, key, value) => {
        set(t, key, value);
        t
      };
      module Generator = {
        /** the type of the function you must call to furnish an RPC invocation with
         either its metadata or a metadata generation error. see \`makeGenerator\`
        for details */
        type complete = (Js.Nullable.t(exn), t) => unit;
        /** consumers of bs-grpc who want to use metadata must implement a function
         of this type. see \`makeGenerator\` for more details */
        type generatorImplementation = (unit, complete) => unit;
        /** to populate a grpc request with metadata, grpc-node requires you to
         supply a metadata generator function, which receives as its first argument
         the call object reflecting the request payload (not available in this
         binding) while the second argument is a function your metadata generator
         function must invoke with either an exception or the resulting metadata */
        [@bs.module "@grpc/grpc-js"]
        [@bs.scope "credentials"]
        external make : generatorImplementation => callCredentials =
          "createFromMetadataGenerator";
      };
    };

    module Credentials = {
      [@bs.module "@grpc/grpc-js"]
      [@bs.scope "credentials"]
      external createInsecure : unit => channelCredentials = "";

      [@bs.module "@grpc/grpc-js"]
      [@bs.scope "credentials"]
      external createSsl : (buffer, buffer, buffer) => channelCredentials = "";

      [@bs.module "@grpc/grpc-js"]
      [@bs.scope "credentials"]
      external combine
        : (channelCredentials, callCredentials)
        => channelCredentials
        = "combineChannelCredentials";

      [@bs.module "@grpc/grpc-js"]
      [@bs.scope "credentials"]
      external combine3
        : (channelCredentials, callCredentials, callCredentials)
        => channelCredentials
        = "combineChannelCredentials";
    }
  };

  /* use this to load a nodejs Buffer object containing a base64-encoded
   * PEM format key/certificate
   */
  [@bs.val] [@bs.module "fs"]
  external loadCert : string => buffer = "readFileSync";
`

const dottedModuleName = moduleName =>
  moduleName.split('.').map((s, i) =>
    s[0].toUpperCase() + s.substr(1)
  ).join('.')
const lastDottedPart = moduleName => {
  const a = moduleName.split('.')
  return a[a.length - 1]
}
const mapMessageType = messageType => messageType[1].toUpperCase() + messageType.substr(2) + '.t';
const mapTypeNameToModuleName = enumTypeName => enumTypeName[1].toUpperCase() + enumTypeName.substr(2)
const mapEnumType = enumTypeName => mapTypeNameToModuleName(enumTypeName) + '.t';
const joinModuleName = (...args) => args.map(s => s[0] == '.' ? s.substr(1) : s).join('.')
const resolveRelative = (moduleName, scopeName) => {
  const scopeParts = scopeName.split('.')
  const moduleParts = moduleName.split('.')
  const max = Math.max(scopeParts.length, moduleParts.length)
  for (let i = 0; i < max; i++)
    if (scopeParts[i] !== moduleParts[i])
      return moduleParts.slice(i).join('.')
  throw new Error("how do i name myself?")
}
const objMap = (o, f) => { let r = {}; for (let k in o) r[k] = f(o[k], k); return r } // TODO get from a standard lib?
const objJoin = (o, s) => { let r = '', i = 0; for (let k in o) r += (i ? s + o[k] : o[k]); return r } // TODO get from a standard lib?
const lower1 = s => s[0].toLowerCase() + s.substr(1)
const upper1 = s => s[0].toUpperCase() + s.substr(1)
const firstPart = s => s.split('.')[0]
/* TODO double-check this work
 * TODO what is this called?
 */
const sortish = (a, f) => {
  for (let i = 0; i < a.length; i++) {
    for (let j = i + 1; j < a.length; j++) {
      if (f(a[i], a[j]) < 0) {
        const tmp = a[i]
        a[i] = a[j]
        a[j] = tmp
      }
    }
  }
}

const mapJustType = (fieldProto, scopeName) => {
  switch (fieldProto.type) {
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_GROUP:
    default:
      return 'unknown_type /*' + type + '*/';
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM:
      return upper1(resolveRelative(mapEnumType(fieldProto.typeName), scopeName))
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE:
      return upper1(resolveRelative(mapMessageType(fieldProto.typeName), scopeName))
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_BOOL:
      return 'bool'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_BYTES:
      return 'UNHANDLED_TYPE_BYTES'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_STRING:
      return 'string'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_DOUBLE:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_FLOAT:
      return 'float'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_INT32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SINT32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_UINT32:
      return 'int'
    /* TODO in the future we'll want more flexibility in how we represent 64-bit values */
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_INT64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SINT64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_UINT64:
      return 'string'
  }
}
const mapType = (field, scopeName) => {
  const justType = mapJustType(field, scopeName)
  switch (field.label) {
    default:
    case protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_OPTIONAL:
      return ['[@bs.optional]', justType]
    case protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED:
      return ['[@bs.optional]', `array(${justType})`]
    case protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_REQUIRED:
      return ['/* required */', justType]
  }
}
/** similar to mapType, but emits 'int' for ENUMs */
const mapTypeForMessageField = (field, scopeName) => {
  if (field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM)
    field = { ...field, type: protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_INT32 }
  return mapType(field, scopeName)
}
function isEnumField(field) { return field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM }
function someEnumFields(fields) { return fields.some(isEnumField) }
/* make function names for converting between protobufjs' representation of values of enums and bs-grpc's representation */
function makeFunNameConvEnumOfInt(enumModuleRef) { return `${upper1(enumModuleRef)}.${lower1(enumModuleRef)}OfInt` }
function makeFunNameConvIntOfEnum(enumModuleRef) { return `${upper1(enumModuleRef)}.intOf${upper1(enumModuleRef)}` }

require('read-all-stream')(process.stdin, { encoding: null }).then(buf => {
  let protoHandleFields = ''
  const reader = pbjs.Reader.create(buf)
  const req = protobufs.google.protobuf.compiler.CodeGeneratorRequest.decode(buf)
  //console.error(util.inspect(req, {depth:999}))

  // XXX deleting noise garbage i don't want to see
  req.protoFile.forEach(protoFile => delete protoFile.sourceCodeInfo)

  /* In order to support custom options in our .proto file, we need to allocate
   * message fields in the protobuf messages that protoc uses to represent our
   * .proto files to our plugin. To do this we need to use the "extend"
   * capability of protobufs. To my intuition, we would apply this step when
   * generating our protoc protobuf compiler, so that the compiler knows about
   * our custom options and how to represent them to our plugin. I
   * haven't been able to figure out a way to do this. Instead, however, we can
   * apparently do the extend at protoc's runtime. Until a better solution is
   * discovered, I am blacklisting the following root packages (__no_emit being
   * my own invention) so that we do not emit code for them.
   *
   * It seems that __no_emit was not actually useful as in order to access any
   * extensions defined by a .proto package with such a name, you'd have to
   * write __no_emit everywhere, and I find that too unattractive. I'm leaving
   * it in here in case someone finds it useful, though.
   *
   * I'm adding 'tin' to this list so that users can import tin.proto and we
   * don't emit code for it, however I've decided that this simply isn't the
   * best way to do this. In the case of tin.proto, for now at least, it would
   * work to simply check whether or not the file defines any messages or
   * services, and omit emission in such a case.
   *
   * TODO investigate using CodeGeneratorRequest.file_to_generate or
   * CodeGeneratorRequest.parameter
   */
  const packagePrefixesToIgnore = ['__no_emit', 'google.', 'tin.']
  req.protoFile = req.protoFile.filter(protoFile =>
    !packagePrefixesToIgnore.some(prefix =>
      protoFile.package.substr(0, prefix.length) == prefix
    )
  )

  const rootModule = { moduleName: '*root*', modules: {} }

  function handleFieldValidationOptions(field) {
    if ('options' in field) {
      const options = field.options
      if (options !== null && '.tin.fieldValidation' in options) {
        const validationSource = options['.tin.fieldValidation']
        return validationSource
      }
    }
  }

  function handleMessageValidationOptions(messageType) {
    /* check for validation criteria */
    if ('options' in messageType) {
      const options = messageType.options
      if (options !== null && '.tin.messageValidation' in options) {
        const validationSource = options['.tin.messageValidation']
        return validationSource
      }
    }
  }

  function handleMessageType(parentModule, messageType) {
    /* Create module for this message type */
    const moduleName = dottedModuleName(joinModuleName(parentModule.moduleName, messageType.name))
    const module = {
      modules: {},
      moduleName
    }
    parentModule.modules[lastDottedPart(moduleName)] = module
    const message = module.t = {
      fields: messageType.field.map(field => ({
        name: field.name,
        type: field.type,
        typeName: field.typeName,
        label: field.label,
        oneofIndex: field.hasOwnProperty('oneofIndex') ? field.oneofIndex : -1,
        validation: handleFieldValidationOptions(field)
      })),
      oneofs: messageType.oneofDecl.map(oneof => ({
        name: oneof.name,
        fields: []
      })),
      validation: handleMessageValidationOptions(messageType),
    }
    messageType.field.forEach((field, iField) => {
      if (field.hasOwnProperty('oneofIndex')) {
        const oneofIndex = field.oneofIndex
        message.oneofs[field.oneofIndex].fields.push(
          message.fields[iField]
        )
      }
    })
    messageType.nestedType.forEach(nestedType => {
      handleMessageType(module, nestedType)
    })
    messageType.enumType.forEach(enumType => {
      handleEnumType(module, enumType)
    })
  }

  function enumName(name) {
    return name.split('_').map(part => part[0].toUpperCase() + part.substr(1).toLowerCase()).join('')
  }

  function mapEnumValues(values) {
    return values.map(enumValue => ({
      name: enumName(enumValue.name),
      number: enumValue.number
    }))
  }

  function handleEnumType(parentModule, enumType) {
    const moduleName = dottedModuleName(joinModuleName(parentModule.moduleName, enumType.name))
    const module = {
      modules: {},
      moduleName,
      t: { enumValues: mapEnumValues(enumType.value) }
    }
    parentModule.modules[lastDottedPart(moduleName)] = module
  }

  /* For each .proto file... */
  req.protoFile.forEach(protoFile => {
    if (!protoFile.package) {
      console.error('your .proto file must contain a package name')
      process.exit(1)
    }
    /* Create module for this proto file */
    const protoFileModuleName = dottedModuleName(protoFile.package)
    const protoFileModule = {
      modules: {},
      moduleName: protoFileModuleName,
      packageName: protoFile.package,
      fileName: protoFile.name,
    }
    rootModule.modules[lastDottedPart(protoFileModuleName)] = protoFileModule
    /* For each message type defined... */
    protoFile.messageType.forEach(messageType => {
      handleMessageType(protoFileModule, messageType)
    })
    protoFile.enumType.forEach(enumType => {
      handleEnumType(protoFileModule, enumType)
    })
    protoFile.service.forEach(service => {
      const moduleName = joinModuleName(protoFileModuleName, service.name)
      const serviceModule = {
        modules: [],
        moduleName,
        /* service modules need this to find their loaded protobuf specs */
        serviceName: service.name,
        rpcs: service.method.map(method => {
          /* TODO support streaming */
          const name = method.name
          const inputType = mapMessageType(method.inputType)
          const outputType = mapMessageType(method.outputType)
          return {
            name,
            inputType,
            outputType
          }
        })
      }
      protoFileModule.modules[lastDottedPart(moduleName)] = serviceModule
    })
  })

  function identifyModules() {
    const foundModules = {}
    recurse(rootModule)
    function recurse(module) {
      foundModules[module.moduleName] = module;
      for (let moduleName in module.modules)
        recurse(module.modules[moduleName])
    }
    return foundModules;
  }
  function identifyModulesArray() {
    const foundModules = []
    recurse(rootModule)
    function recurse(module) {
      foundModules.push(module)
      for (let moduleName in module.modules)
        recurse(module.modules[moduleName])
    }
    return foundModules;
  }
  function identifyServices() {
    const foundServices = {}
    recurse(rootModule)
    function recurse(module) {
      if ('rpcs' in module)
        foundServices[module.moduleName] = {
          fileName: module.fileName,
          module,
        }
      for (let moduleName in module.modules)
        recurse(module.modules[moduleName])
    }
    return foundServices
  }
  const dependencies = []
  identifyModulesArray().forEach(module => {
    if (module.moduleName !== '*root*') {
      dependencies.push(['*root*', module.moduleName])
      if (module.moduleName.indexOf('.') >= 0)
        dependencies.push([moduleDirName(module.moduleName), module.moduleName])
    }
    if ('t' in module) {
      /* we could emit our 't' without this, but this is necessary for
       * detecting cyclic dependencies */
      dependencies.push([module.moduleName, module.moduleName + '.t'])
      if ('fields' in module.t) {
        module.t.fields.forEach(field => {
          if (field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM
            || field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE) {
            dependencies.push([mapMessageType(field.typeName), module.moduleName])
          }
        })
      }
    }
    if ('rpcs' in module) {
      module.rpcs.forEach(rpc => {
        dependencies.push([rpc.inputType, module.moduleName])
        dependencies.push([rpc.outputType, module.moduleName])
      })
    }
  }, [])
  const dependencySortedModuleNames = toposort(dependencies).slice(1)

  const emitModule = module => {
    let code = ''
    /* diagnostic output */
    code += `/* fileName = "${module.fileName}" */\n`
    code += `/* moduleName = "${module.moduleName}" */\n`
    /* Invoke grpc-node's load() method to generate and load javascript
     * bindings to our .proto
     */
    if ('fileName' in module) {
      /* TODO will path be correct at runtime?
       * TODO escape path
       */
      code += `
        type grpcProtoHandle;
        [@bs.get] external getProtoHandle : grpcLoadResult => grpcProtoHandle = "${module.packageName}";
        let myProtoHandle = grpcLoadProto(Node.Path.resolve(Node.Process.cwd(), ${JSON.stringify(module.fileName)})) |> getProtoHandle;
      `
    }
    /* sort sub-modules by order of dependency */
    const subModuleOrder = Object.keys(module.modules).map(shortModuleName => {
      const moduleName = module.modules[shortModuleName].moduleName
      return {
        shortModuleName,
        position: dependencySortedModuleNames.indexOf(moduleName)
      }
    })
    subModuleOrder.sort((a, b) => a.position - b.position)
    /* emit code for each sub-module in order */
    subModuleOrder.forEach(subModulePosition => {
      const shortModuleName = subModulePosition.shortModuleName
      code += `module ${shortModuleName} {\n`
      code += emitModule(module.modules[shortModuleName])
      code += `};\n`
    })
    /* emit code for any type contained in our module */
    if ('t' in module) {
      if ('fields' in module.t) {
        const hasEnumField = someEnumFields(module.t.fields)
        code += `/* Message module */
          [@bs.deriving abstract]
          type t =
        `
        if (module.t.fields.length) {
          code += "{\n"
          module.t.fields.forEach(field => {
            const [fieldQualifier, fieldType] = mapTypeForMessageField(field, module.moduleName)
            code += `${fieldQualifier} ${field.name} : ${fieldType},\n`
          })
          module.t.oneofs.forEach(oneof => {
            code += `/* oneof */ ${oneof.name}: string,\n`;
          })
          code += "}";
        } else {
          code += "{ /* this type needs at least one field */ [@bs.optional] dontSetMe : string }"
        }
        code += ";\n";
        /* to support enums, we need to provide our own accessors of enum
         * fields that convert between protobufjs' representation of enums
         * (javascript Number values) and our own variant type */
        if (hasEnumField) {
          /* first shadow the deriving abstract constructor function */
          code += `/** message constructor (shadows the deriving abstract constructor) */
            let t = (
          `
          module.t.fields.forEach(field => {
            if (field.oneofIndex < 0) {
              code += `~${field.name}=?,\n`
            }
          })
          module.t.oneofs.forEach(oneof => {
            code += `~${oneof.name},\n`
          })
          code += '()) => t(\n'
          module.t.fields.forEach(field => {
            if (isEnumField(field)) {
              const enumModuleRef = resolveRelative(mapTypeNameToModuleName(field.typeName), module.moduleName)
              const conv = makeFunNameConvIntOfEnum(enumModuleRef)
              code += `~${lower1(field.name)} =? (`
              if (field.label == protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_OPTIONAL)
                code += `Validation.optionMap`
              if (field.label == protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED)
                code += `Validation.optionMap @@ Array.map`
              code += `@@ ${conv}) @@ ${lower1(field.name)},\n`
            } else {
              code += `~${lower1(field.name)}?,\n`
            }
          })
          code += `());\n`
          module.t.fields.forEach(field => {
            if (isEnumField(field)) {
              const enumModuleRef = resolveRelative(mapTypeNameToModuleName(field.typeName), module.moduleName)
              const conv = makeFunNameConvEnumOfInt(enumModuleRef)
              code += `/* enum converting getter */
                let ${field.name}Get =
              `
              if (field.label == protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_OPTIONAL)
                code += `Validation.optionMap`
              if (field.label == protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED)
                code += `Validation.optionMap @@ Array.map`
              code += `@@ ${conv} << ${field.name}Get;
              `
            }
          })
        }
        /* to support protobufs oneof fields, we create a variant type for
         * each oneof.
         */
        module.t.oneofs.forEach(oneof => {
          /* variant type for oneof */
          code += `type ${oneof.name} =\n`
          oneof.fields.forEach(field => {
            const justType = mapJustType(field, module.moduleName)
            const constructorName = makeConstructorName(justType)
            code += `| ${upper1(field.name)}(${constructorName})\n`
          })
          code += ';\n'
        })
        /* Emit a new constructor function overriding the one emitted by
         * [@bs.deriving abstract] which accepts our oneof variants
         *
         * TODO hide the abstract constructor function "t"
         */
        code += `/* safe message constructor (may replace t()) */\nlet make = (\n`
        module.t.fields.forEach(field => {
          if (field.oneofIndex < 0) {
            code += `~${field.name}=?,\n`
          }
        })
        module.t.oneofs.forEach(oneof => {
          code += `~${oneof.name},\n`
        })
        code += '()) => t(\n'
        module.t.fields.forEach(field => {
          /* Note the question mark here indicates that we will be passing
           * an option-boxed values explicitly
           */
          code += `~${field.name} =?`
          if (field.oneofIndex >= 0) {
            const oneof = module.t.oneofs[field.oneofIndex]
            code += `(${oneof.name} |> /* fun1 */ fun\n`
            oneof.fields.forEach(field2 => {
              const varName = field === field2 ? 'x' : '_';
              const valCode = field === field2 ? `Some(x)` : 'None';
              code += `| ${upper1(field2.name)}(${varName}) => ${valCode}\n`
            })
            code += `),`
          } else {
            code += `${field.name},`
          }
          code += `\n`
        })
        module.t.oneofs.forEach(oneof => {
          code += `~${oneof.name} = (${oneof.name} |> (/* fun2 */ fun\n`
          oneof.fields.forEach(field1 => {
            code += `| ${upper1(field1.name)}(_) => ${JSON.stringify(field1.name)}\n`
          })
          code += `))\n,\n`
        })
        code += `());\n`
        /* We'll also override the oneofs' accessor functions (which would
         * only give us a string indicating which of a oneof's fields
         * contains a value) to provide a value of the variant type we
         * created to represent each oneof field
         */
        module.t.oneofs.forEach(oneof => {
          code += `/* Oneof variant getter */
          let ${oneof.name} = x => x |> ${oneof.name}Get |> (/* fun3 */ fun\n`
          oneof.fields.forEach(field => {
            code += `| ${JSON.stringify(field.name)} => ${upper1(field.name)}(
              x |> ${field.name}Get |> ( /* fun4 */ fun
              | Some (x) => x
              | None => raise(BsGrpcDecoderError("expected Some ${field.name}"))
              )
            )\n`
          })
          code += `
          | _ => raise(ImpossibleError("decoding oneof field switch invalid"))
          );
          `
        })
        const fieldsToValidate = module.t.fields.filter(field =>
          field.validation ||
          field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE
        )
        if (fieldsToValidate.length == 0) {
          code += `
            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          `
        } else {
          code += `
            /* sanitize, validate, normalize */
            let validate = x =>
              Future.make(resolve => {
            `
          fieldsToValidate.forEach(field =>
            code += `let ${field.name}Ref = ref(x |. ${field.name}Get);\n`
          )
          code += `
                let n = ref(${fieldsToValidate.length});
                let failed = ref(false);
                /* message is valid; build the normalized message */
                /* TODO makeMessage is probably vestigial at this point
                let makeMessage = () => {
                  Belt.Result.Ok(t(
            `
          fieldsToValidate.forEach(field =>
            code += `~${field.name}=?${field.name}Ref^,\n`
          )
          code += `
                  ()))
                };
                */
                let wholeMessageValidation =
            `
          if (module.t.validation) {
            code += `
                  Validation.fieldMap @@
                  Validation.futureMap @@
                  Validation.resultOptionFlatMap @@
                  (x => {
                      open Validation;
                      ${module.t.validation}
                    }
                  );
              `
          } else {
            code += `x => x;`
          }
          code += `
                let fail = (fieldName, errMsg) => {
                  failed := true;
                  resolve(
                    Belt.Result.Error(
                      {j|error validating field $fieldName: $errMsg|j},
                    ),
                  )
                };
                let tick = (field, y) => {
                  if (!failed^) {
                    field := y;
                    n := n^ - 1;
                    if (n^ == 0) {
                      t(
            `
          module.t.fields.forEach(field => {
            if (fieldsToValidate.indexOf(field) < 0) {
              code += `~${field.name} =? x |. ${field.name}Get,\n`
            } else {
              code += `~${field.name} =? ${field.name}Ref^,\n`
            }
          })
          module.t.oneofs.forEach(oneof => {
            code += `/* oneof arg */ ~${oneof.name} = `
            oneof.fields.forEach(field => {
              if (fieldsToValidate.indexOf(field) < 0) {
                code += `x |. ${field.name}Get != None ? "${field.name}" :\n`
              } else {
                code += `${field.name}Ref^ != None ? "${field.name}" :\n`
              }
            })
            code += `raise(Validation.EmptyOneof(${quote(oneof.name)})),/* oneof arg done */\n`
          })
          code += `
                      ())
                      |> (x=>Some(x))
                      |> Validation.value(${quote(lastDottedPart(module.moduleName))})
                      |> wholeMessageValidation
                      |> Validation.required
                      |. Validation.fold(opt => resolve(Belt.Result.Ok(Belt.Option.getExn(opt))), fail);
                    }
                  }
                };
                open Validation;
          `
          module.t.fields.forEach(field => {
            if (field.validation != null) {
              code += `/* field validation */
                ${field.name}Ref^
                |> value(${quote(field.name)})
                |> ${field.validation}
                |. fold(tick(${field.name}Ref), fail)
                |. ignore;
              `
            } else if (field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE) {
              let validationCode =
                `fieldValidatorOfMessageValidator @@ ${moduleDirName(mapJustType(field, module.moduleName))}.validate`
              if (field.label == protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED)
                validationCode = `repeated(${validationCode})`
              code += `/* message field validation */
                ${field.name}Ref^
                |> value(${quote(field.name)})
                |> ${validationCode}
                |. fold(tick(${field.name}Ref), fail)
                |. ignore;
              `
            }
          })
          code += `
            });
          `
        }
        code += `
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = ${quote(lastDottedPart(module.moduleName))};

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        `
      } else if ('enumValues' in module.t) {
        const shortName = lastDottedPart(module.moduleName)
        code += `
          /* enum type */
          type t =
        `
        module.t.enumValues.forEach(enumValue => {
          code += `| ${enumValue.name}\n`
        })
        code += `;
          /** convert a grpc enum ordinal to its ${shortName}.t counterpart; internal */
          let ${lower1(shortName)}OfInt = fun
        `
        module.t.enumValues.forEach(enumValue => {
          code += `| ${enumValue.number} => ${enumValue.name}\n`
        })
        code += `
          | x => raise(BsGrpcDecoderError({j|bs-grpc encountered invalid ${shortName} enum value $x|j}));
          /** convert a ${shortName}.t to its the grpc enum ordinal counterpart; internal */
          let intOf${upper1(shortName)} = fun
        `
        module.t.enumValues.forEach(enumValue => {
          code += `| ${enumValue.name} => ${enumValue.number}\n`
        })
      }
    }
    /* emit code for any RPCs */
    if ('rpcs' in module) {
      module.rpcs.forEach(rpc => {
        const inputType = resolveRelative(rpc.inputType, module.moduleName)
        const outputType = resolveRelative(rpc.outputType, module.moduleName)
        code += `
          module ${upper1(rpc.name)}Rpc {
            /* Rpc module */
            /** the input/request type of the ${rpc.name} RPC */
            type inputType = ${inputType};
            /** the output/reply type of the ${rpc.name} RPC */
            type outputType = ${outputType};
            /** the type of the object from which rpc implementations may
             * obtain request payload and metadata. an object of this type is
             * passed to your rpc implementation. */
            [@bs.deriving abstract]
            type call = { request: inputType };
            /** server implementation function type. request payload and
             * metadata can be obtained via the \`call\` argument furnished to
             * your rpc implementation. the second argument allows you to
             * furnish a reply, although three of its four arguments should be
             * unused. */
            type t = (
              call,
              (.
                justNull,
                outputType,
                justNull,
                justNull
              ) => unit
            ) => unit;
            let getMeta : call => Js.Dict.t(Js.Json.t) = [%bs.raw {|
              call => call.metadata.getMap()
            |}];
          };
        `
      })
      code += `
        /** objects of this type are actually grpc service client constructor
         * functions, however, they have a property, "service," whose value is
         * used to add services to a server object, too. */
        type grpcServiceObject;
        [@bs.get]
        external myServiceClient
          : grpcProtoHandle => grpcServiceObject
          = ${JSON.stringify(module.serviceName)};
        let myServiceClient = myProtoHandle |> myServiceClient;
        module Client = {
          /** a client object for the ${module.serviceName} service */
          type t;
          /** the type of the error argument in the callback you supply when
           you invoke an rpc */
          type maybeError = Js.Nullable.t(grpcClientRpcInvokeError);
          /* client construction */
          let makeClient : (grpcServiceObject, string, channelCredentials) => t = [%bs.raw "(x,y,z) => new x(y,z)"];
          /** construct a client for the ${rootModule.packageName}.${module.moduleName} grpc service. arguments:
           serverAddress: string of address and port of server (e.g. "127.0.0.1:12345")
           chanCreds: your channel credentials */
          let makeClient = (serverAddress, chanCreds) => makeClient(myServiceClient, serverAddress, chanCreds);
      `
      module.rpcs.forEach(rpc => {
        const rpcModuleRef = upper1(rpc.name) + 'Rpc'
        const myModuleName = rpcModuleRef
        const inputType = rpcModuleRef + '.inputType'
        const outputType = rpcModuleRef + '.outputType'
        code += `
          module ${myModuleName} = {
            /** the type of the callback you must supply when you invoke an rpc */
            type callback = (maybeError, ${outputType}) => unit;
            /** invoke an rpc using callback style. arguments:
             t: the client over which to send the rpc request
             ${inputType}: the request payload message
             callback: a function which will be invoked when a reply from the
               server is available, or when an error occurs */
            [@bs.send]
            external invoke : (t, ${inputType}, callback) => unit = ${quote(lower1(rpc.name))};
            /** invoke an rpc using futures */
            let invokeFuture = (client, input) => Future.make(resolve => invoke(client, input, (err, res) => {
              /* note: isNullable means "is nullish" */
              if (err |. Js.Nullable.isNullable) {
                /* no error */
                resolve(Belt.Result.Ok(res))
              } else {
                /* error */
                resolve(Belt.Result.Error(err))
              }
            }));
            /** invoke an rpc using promises */
            let invokePromise = (client, input) => Js.Promise.make((~resolve, ~reject) => {
              invoke(client, input, (err, res) => {
                switch (err |. Js.Nullable.toOption) {
                | Some(err) => reject(. GrpcClientRpcInvokeError(err))
                | None => resolve(. res)
                }
              });
            });
          }
        `
      })
      code += `
        };
        type grpcServiceServer;
        [@bs.get]
        external getServerServiceHandle : grpcServiceObject => grpcServiceServer =
          "service";
        let myServerServiceHandle = myServiceClient |> getServerServiceHandle;
      `
      /* the deriving abstract record type is chosen because it can be fed
       * directly to grpc-node's grpc.Server#addService method
       */
      code += '/* Service implementation type */\n[@bs.deriving abstract]\ntype t = {\n'
      module.rpcs.forEach(rpc => {
        code += `${lower1(rpc.name)}: ${upper1(rpc.name)}Rpc.t,\n`;
      })
      code += `};
        [@bs.send] external addService : (server, grpcServiceServer, t) => unit = "";
        let addService = (server, t) =>
          addService(server, myServerServiceHandle, t);
        /** creates an implementation of the ${module.serviceName}. The RPC
         * implementations you pass to this function will only be invoked after
         * any sanitization/validation/normalization code has processed the
         * message without error. */
        let make = (
      `
      module.rpcs.forEach(rpc => {
        code += `~${lower1(rpc.name)},\n`;
        code += `~${lower1(rpc.name)}ErrorHandler,\n`;
      })
      code += `\n) => t(\n`;
      module.rpcs.forEach(rpc => {
        code += `
                ~${lower1(rpc.name)}=
          (call, callback) => {
            let request = call |. ${upper1(resolveRelative(rpc.name, module.moduleName))}Rpc.requestGet;
            ${moduleDirName(resolveRelative(rpc.inputType, module.moduleName))}.validate(request)
            |. Future.get(x => {
                 switch (x) {
                 | Ok(request) => ${lower1(rpc.name)}(call, request, callback)
                 | Error(errMsg) =>
                   errMsg |. ${lower1(rpc.name)}ErrorHandler |> reply(callback)
                 };
               });
          },
        `
      })
      code += `)\n`;
    }
    if (module === rootModule) {
      const services = identifyServices()
      const serviceModules = []
      for (let k in services)
        serviceModules.push(services[k].module)
      const serverModuleCode = makeServerModule(serviceModules)

      code += serverModuleCode
    }
    return code
  }

  const moduleMeat = emitModule(rootModule)

  const emission = FILE_MAGIC
    + preBoilerPlate
    + boilerPlate
    + moduleMeat
    + boilerPlate2

  if (process.stdout.isTTY) {
    console.log('stdout is a TTY; printing human-readable data')
    console.log('output module tree:', util.inspect(rootModule, { depth: 99 }))
    console.log('output source code:')
    console.log(emission)
  } else {
    process.stdout.write(
      protobufs.google.protobuf.compiler.CodeGeneratorResponse.encode({
        file: [{
          name: 'Grpc.re',
          content: emission
        }]
      }).finish()
    )
  }
}).catch(err => {
  console.error(__filename, "error", err)
})
